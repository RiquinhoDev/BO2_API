// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ src/services/sync/hotmartSync.service.ts (CORRIGIDO)
// HOTMART SYNC SERVICE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// âœ… CORREÃ‡ÃƒO: Integrado com hotmart.adapter.ts
// âœ… USA DADOS REAIS da API Hotmart
// âœ… Remove MOCK vazio
//
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import { Product, User } from "../../../models"
import logger from "../../../utils/logger"
import { dualWriteUserData } from "../../userProductService"
import hotmartAdapter from "./hotmart.adapter"


// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TYPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

interface HotmartSyncData {
  email: string
  subdomain: string
  name?: string
  status?: string
  progress?: number
  lastAccess?: string | Date
  classes?: any[]
}

interface SyncResult {
  success: boolean
  stats: {
    total: number
    inserted: number
    updated: number
    errors: number
  }
  errors?: string[]
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN SYNC FUNCTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Sincronizar dados Hotmart
 * 
 * IMPORTANTE: Esta funÃ§Ã£o faz sync de UM user por vez
 * Para batch sync, usar syncHotmartBatch()
 * 
 * @param data - Dados do user Hotmart
 * @returns Resultado da sincronizaÃ§Ã£o
 */
export async function syncHotmart(data: HotmartSyncData): Promise<SyncResult> {
  logger.info('[HotmartSync] Iniciando sync', { email: data.email, subdomain: data.subdomain })
  
  const result: SyncResult = {
    success: false,
    stats: {
      total: 1,
      inserted: 0,
      updated: 0,
      errors: 0
    },
    errors: []
  }
  
  try {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 1: VALIDAÃ‡ÃƒO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    if (!data.email || !data.subdomain) {
      throw new Error('Missing required fields: email, subdomain')
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 2: IDENTIFICAR PRODUTO
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const product = await Product.findOne({
      platform: 'hotmart',
      'platformData.subdomain': data.subdomain
    })
    
    if (!product) {
      throw new Error(`Produto Hotmart nÃ£o encontrado para subdomain: ${data.subdomain}`)
    }
    
    logger.info('[HotmartSync] Produto encontrado', {
      productId: product._id,
      productName: product.name
    })
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 3: BUSCAR OU CRIAR USER
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    let user = await User.findOne({ email: data.email })
    let wasInserted = false
    
    if (!user) {
      logger.info('[HotmartSync] Criando novo user', { email: data.email })
      
      user = await User.create({
        email: data.email,
        name: data.name || 'Unnamed User'
      })
      
      wasInserted = true
      result.stats.inserted++
    } else {
      logger.info('[HotmartSync] User existente encontrado', { userId: user._id })
      result.stats.updated++
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 4: DUAL WRITE (V1 + V2)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Validar status (garantir que Ã© um dos valores aceites)
    const validStatuses = ['ACTIVE', 'INACTIVE', 'SUSPENDED', 'CANCELLED']
    const status = validStatuses.includes(data.status || '') 
      ? (data.status as 'ACTIVE' | 'INACTIVE' | 'SUSPENDED' | 'CANCELLED')
      : 'ACTIVE' as const
    
    const productData = {
      status,
      progress: {
        percentage: data.progress || 0,
        classes: data.classes || []
      },
      engagement: {
        lastActivityAt: data.lastAccess ? new Date(data.lastAccess) : new Date()
      }
    }
    
    await dualWriteUserData(
      user.id,
      product.code,
      productData
    )
    
    logger.info('[HotmartSync] Dual write completo', {
      userId: user._id,
      productId: product._id,
      wasInserted
    })
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 5: SUCCESS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    result.success = true
    
    logger.info('[HotmartSync] âœ… Sync completo', {
      email: data.email,
      wasInserted,
      stats: result.stats
    })
    
    return result
    
  } catch (error: any) {
    result.success = false
    result.stats.errors++
    result.errors = [error.message]
    
    logger.error('[HotmartSync] âŒ Erro no sync', {
      email: data.email,
      error: error.message,
      stack: error.stack
    })
    
    return result
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// BATCH SYNC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Sincronizar mÃºltiplos users Hotmart de uma vez
 * 
 * @param users - Array de dados de users
 * @param subdomain - Subdomain comum (ou passar em cada user)
 * @returns Resultado agregado
 */
export async function syncHotmartBatch(
  users: HotmartSyncData[],
  subdomain?: string
): Promise<SyncResult> {
  logger.info('[HotmartSync] Iniciando batch sync', { total: users.length })
  
  const result: SyncResult = {
    success: true,
    stats: {
      total: users.length,
      inserted: 0,
      updated: 0,
      errors: 0
    },
    errors: []
  }
  
  for (const userData of users) {
    // Se subdomain comum foi passado, usar ele
    const data: HotmartSyncData = subdomain
      ? { ...userData, subdomain }
      : userData
    
    try {
      const userResult = await syncHotmart(data)
      
      result.stats.inserted += userResult.stats.inserted
      result.stats.updated += userResult.stats.updated
      result.stats.errors += userResult.stats.errors
      
      if (!userResult.success) {
        result.success = false
        if (userResult.errors) {
          result.errors?.push(...userResult.errors)
        }
      }
      
    } catch (error: any) {
      result.success = false
      result.stats.errors++
      result.errors?.push(`${userData.email}: ${error.message}`)
      
      logger.error('[HotmartSync] Erro no batch', {
        email: userData.email,
        error: error.message
      })
    }
  }
  
  logger.info('[HotmartSync] âœ… Batch sync completo', {
    stats: result.stats,
    successRate: `${((result.stats.total - result.stats.errors) / result.stats.total * 100).toFixed(1)}%`
  })
  
  return result
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ… FULL SYNC (INTEGRADO COM ADAPTER REAL!)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Sincronizar TODOS os users de um produto Hotmart
 * 
 * âœ… CORRIGIDO: Usa hotmart.adapter.ts para buscar dados reais
 * 
 * @param subdomain - Subdomain do produto (opcional - usa env se nÃ£o fornecido)
 * @returns Resultado agregado
 */
export async function syncHotmartFull(subdomain?: string): Promise<SyncResult> {
  const actualSubdomain = subdomain || process.env.subdomain || 'ograndeinvestimento-bomrmk'
  
  logger.info('[HotmartSync] Iniciando full sync', { subdomain: actualSubdomain })
  
  const result: SyncResult = {
    success: false,
    stats: {
      total: 0,
      inserted: 0,
      updated: 0,
      errors: 0
    },
    errors: []
  }
  
  try {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // âœ… USAR ADAPTER REAL (NÃƒO MOCK!)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    logger.info('[HotmartSync] ğŸš€ Buscando dados via hotmart.adapter...')
    
    const adapterData = await hotmartAdapter.fetchHotmartDataForSync({
      includeProgress: true,
      includeLessons: true,
      progressConcurrency: 5
    })
    
    if (adapterData.length === 0) {
      logger.warn('[HotmartSync] âš ï¸ Adapter retornou 0 users')
      result.success = true
      return result
    }
    
    logger.info('[HotmartSync] âœ… Adapter retornou ${adapterData.length} users')
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // CONVERTER DADOS DO ADAPTER PARA FORMATO DO SYNC
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const usersToSync: HotmartSyncData[] = adapterData.map((user) => ({
      email: user.email,
      subdomain: actualSubdomain,
      name: user.name,
      status: "ACTIVE", // Adapter nÃ£o retorna status, assumir ACTIVE
      progress: user.progress?.percentage || 0,
      lastAccess: safeDate((user as any).lastAccessDate),
      classes: user.className
        ? [
            {
              classId: user.classId || "",
              className: user.className
            }
          ]
        : []
    }))
    
    logger.info('[HotmartSync] ğŸ“¦ Convertidos ${usersToSync.length} users para sync')
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PROCESSAR BATCH
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const batchResult = await syncHotmartBatch(usersToSync, actualSubdomain)
    
    logger.info('[HotmartSync] âœ… Full sync completo', {
      stats: batchResult.stats
    })
    
    return batchResult
    
  } catch (error: any) {
    result.success = false
    result.errors = [error.message]
    
    logger.error('[HotmartSync] âŒ Erro no full sync', {
      subdomain: actualSubdomain,
      error: error.message,
      stack: error.stack
    })
    
    return result
  }
}
function safeDate(value: unknown): Date {
  if (value instanceof Date) return value
  if (typeof value === "string" || typeof value === "number") {
    const d = new Date(value)
    return Number.isNaN(d.getTime()) ? new Date() : d
  }
  return new Date()
}
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export default {
  syncHotmart,
  syncHotmartBatch,
  syncHotmartFull
}