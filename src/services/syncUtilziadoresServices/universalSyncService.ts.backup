// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ğŸ“ src/services/syncUtilizadoresServices/universalSync.service.ts
// Service: Universal Sync - Unifica Manual + AutomÃ¡tico
// âœ… VERSÃƒO FINAL: EscalÃ¡vel, flexÃ­vel, sem hardcodes
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

import syncReportsService from './syncReports.service'
import SyncHistory from '../../models/SyncModels/SyncHistory'
import User from '../../models/user'
import type { SyncType, TriggerType } from '../../models/SyncModels/SyncReport'
import mongoose from 'mongoose'
import { Product, UserProduct } from '../../models'

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TYPE HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

type LeanProduct = {
  _id: mongoose.Types.ObjectId
  code: string
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TYPES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export interface UniversalSourceItem {
  // Base
  email?: string
  name?: string

  // IDs genÃ©ricos
  id?: string
  userId?: string

  // HOTMART
  hotmartUserId?: string
  purchaseDate?: Date | string | null
  signupDate?: Date | string | null
  firstAccessDate?: Date | string | null
  lastAccessDate?: Date | string | null
  plusAccess?: string
  classId?: string
  className?: string
  productCode?: string // âœ… ADICIONADO
  currentModule?: number // âœ… ADICIONADO
  
  // âœ… CORRIGIDO: Estrutura de progresso unificada
  progress?: {
    percentage?: number // Para todas as plataformas
    completed?: number  // Hotmart especÃ­fico
    lessons?: Array<{
      pageId?: string
      pageName?: string
      isCompleted?: boolean
      completedDate?: Date | string | null
    }>
  }
  
  accessCount?: number | string
  engagementLevel?: string
  
  // âœ… CORRIGIDO: Engagement unificado
  engagement?: {
    engagementScore?: number
  }

  // CURSEDUCA
  curseducaUserId?: string
  curseducaUuid?: string
  groupId?: string | number
  groupName?: string
  subscriptionType?: 'MONTHLY' | 'ANNUAL'
  enrolledAt?: Date | string | null
  joinedDate?: Date | string | null

  // DISCORD
  discordUserId?: string
  username?: string
  roles?: string[]

  // Extra
  [key: string]: unknown
}

export interface UniversalSyncConfig {
  // IdentificaÃ§Ã£o
  syncType: SyncType
  jobName: string
  jobId?: string

  // Trigger
  triggeredBy: TriggerType
  triggeredByUser?: string

  // ConfiguraÃ§Ãµes
  fullSync: boolean
  includeProgress: boolean
  includeTags: boolean
  batchSize: number

  // Dados da fonte
  sourceData: UniversalSourceItem | UniversalSourceItem[]

  // Callbacks opcionais
  onProgress?: (progress: SyncProgress) => void
  onError?: (error: SyncError) => void
  onWarning?: (warning: SyncWarning) => void
}

export interface SyncProgress {
  current: number
  total: number
  percentage: number
  message: string
}

export interface SyncError {
  message: string
  userId?: string
  userEmail?: string
  stack?: string
  code?: string
}

export interface SyncWarning {
  message: string
  userId?: string
  context?: string
}

interface ProcessItemResult {
  action: 'inserted' | 'updated' | 'unchanged' | 'skipped'
  userId?: string
}

export interface UniversalSyncResult {
  success: boolean
  reportId: string
  syncHistoryId: string
  stats: {
    total: number
    inserted: number
    updated: number
    errors: number
    skipped: number
    unchanged: number
  }
  duration: number
  errors: SyncError[]
  warnings: SyncWarning[]
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const normalizeEmail = (email: string) => email.trim().toLowerCase()

const getDocId = (doc: unknown, label: string): string => {
  const d = doc as { _id?: unknown; id?: unknown }
  const raw = d?._id ?? d?.id

  if (raw === undefined || raw === null) {
    throw new Error(`${label} sem _id/id`)
  }

  return String(raw)
}

const toDateOrNull = (value: unknown): Date | null => {
  if (!value) return null
  if (value instanceof Date) return Number.isNaN(value.getTime()) ? null : value
  if (typeof value === 'string' || typeof value === 'number') {
    const d = new Date(value)
    return Number.isNaN(d.getTime()) ? null : d
  }
  return null
}

const toNumber = (value: unknown, fallback = 0): number => {
  if (typeof value === 'number') return Number.isFinite(value) ? value : fallback
  if (typeof value === 'string') {
    const n = Number(value)
    return Number.isFinite(n) ? n : fallback
  }
  return fallback
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// âœ… NOVO: MAPEAMENTO DINÃ‚MICO DE PRODUTOS (SEM HARDCODE!)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/**
 * Determina o produto correto baseado nos dados do item e na plataforma
 * âœ… Totalmente escalÃ¡vel - busca produtos dinamicamente na BD
 */
async function determineProductId(
  item: UniversalSourceItem,
  syncType: SyncType
): Promise<mongoose.Types.ObjectId | null> {
  
  if (syncType === 'hotmart') {
    // Hotmart: usar productCode se fornecido, senÃ£o buscar produto default
    const productCode = item.productCode || 'OGI_V1'
    
    const product = await Product.findOne({ 
      code: productCode,
      platform: 'hotmart',
      isActive: true
    }).select('_id').lean() as LeanProduct | null
    
    if (!product) {
      console.warn(`âš ï¸ [ProductMapping] Produto Hotmart nÃ£o encontrado: ${productCode}`)
    }
    
    return product?._id || null
  }
  
  if (syncType === 'curseduca') {
    // âœ… ESTRATÃ‰GIA ESCALÃVEL: Buscar produto por curseducaGroupId
    // Isto permite adicionar novos grupos sem mudar cÃ³digo!
    
    const groupId = String(item.groupId || '') // Normalizar para string
    
    if (groupId) {
      // 1Âª tentativa: Buscar por curseducaGroupId exato
      const product = await Product.findOne({
        platform: 'curseduca',
        'platformData.curseducaGroupId': groupId,
        isActive: true
      }).select('_id code').lean() as LeanProduct | null
      
      if (product) {
        console.log(`âœ… [ProductMapping] Produto encontrado por groupId ${groupId}: ${product.code}`)
        return product._id
      }
    }
    
    // 2Âª tentativa: Buscar por subscriptionType (MONTHLY/ANNUAL)
    if (item.subscriptionType) {
      const product = await Product.findOne({
        platform: 'curseduca',
        'platformData.subscriptionType': item.subscriptionType,
        isActive: true
      }).select('_id code').lean() as LeanProduct | null
      
      if (product) {
        console.log(`âœ… [ProductMapping] Produto encontrado por subscriptionType ${item.subscriptionType}: ${product.code}`)
        return product._id
      }
    }
    
    // 3Âª tentativa: Buscar por groupName (case-insensitive)
    if (item.groupName) {
      const product = await Product.findOne({
        platform: 'curseduca',
        name: { $regex: new RegExp(item.groupName, 'i') },
        isActive: true
      }).select('_id code').lean() as LeanProduct | null
      
      if (product) {
        console.log(`âœ… [ProductMapping] Produto encontrado por groupName "${item.groupName}": ${product.code}`)
        return product._id
      }
    }
    
    // 4Âª tentativa: Produto default da plataforma (primeiro ativo)
    const defaultProduct = await Product.findOne({
      platform: 'curseduca',
      isActive: true
    }).select('_id code').lean() as LeanProduct | null
    
    if (defaultProduct) {
      console.warn(`âš ï¸ [ProductMapping] Usando produto default CursEDuca: ${defaultProduct.code} (groupId: ${groupId})`)
      return defaultProduct._id
    }
    
    console.error(`âŒ [ProductMapping] Nenhum produto CursEDuca ativo encontrado!`)
    return null
  }
  
  if (syncType === 'discord') {
    // Discord: buscar produto por code ou primeiro ativo
    const product = await Product.findOne({
      $or: [
        { code: 'DISCORD_COMMUNITY' },
        { platform: 'discord', isActive: true }
      ]
    }).select('_id code').lean() as LeanProduct | null
    
    if (!product) {
      console.warn(`âš ï¸ [ProductMapping] Produto Discord nÃ£o encontrado`)
    }
    
    return product?._id || null
  }
  
  return null
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// MAIN SYNC FUNCTION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export const executeUniversalSync = async (
  config: UniversalSyncConfig
): Promise<UniversalSyncResult> => {
  console.log('ğŸš€ [UniversalSync] Iniciando sync:', config.jobName)
  console.log(`   ğŸ“Š Tipo: ${config.syncType}`)
  console.log(`   ğŸ¯ Trigger: ${config.triggeredBy}`)
  console.log(`   ğŸ“¦ Batch Size: ${config.batchSize}`)

  const startTime = Date.now()

  let reportId: string | null = null
  let syncHistoryId: string | null = null

  const stats = {
    total: 0,
    inserted: 0,
    updated: 0,
    errors: 0,
    skipped: 0,
    unchanged: 0
  }

  const errors: SyncError[] = []
  const warnings: SyncWarning[] = []

  let rid = ''
  let hid = ''

  try {
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 1: CRIAR SYNCREPORT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const report = await syncReportsService.createSyncReport({
      jobId: config.jobId,
      jobName: config.jobName,
      syncType: config.syncType,
      triggeredBy: config.triggeredBy,
      triggeredByUser: config.triggeredByUser,
      syncConfig: {
        fullSync: config.fullSync,
        includeProgress: config.includeProgress,
        includeTags: config.includeTags,
        batchSize: config.batchSize
      }
    })

    rid = getDocId(report, 'SyncReport')
    reportId = rid

    console.log(`âœ… [UniversalSync] Report criado: ${rid}`)

    await syncReportsService.addReportLog(rid, 'info', `Iniciando sincronizaÃ§Ã£o ${config.syncType}`, {
      fullSync: config.fullSync,
      batchSize: config.batchSize,
      dataSourceSize: Array.isArray(config.sourceData) ? config.sourceData.length : 1
    })

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 2: CRIAR SYNCHISTORY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const syncHistory = await SyncHistory.create({
      type: config.syncType,
      status: 'running',
      startedAt: new Date(),
      stats: {
        total: 0,
        added: 0,
        updated: 0,
        conflicts: 0,
        errors: 0
      },
      user: config.triggeredByUser || undefined,
      triggeredBy: {
        type: config.triggeredBy,
        userId: config.triggeredByUser,
        cronJobId: config.jobId
      }
    })

    hid = getDocId(syncHistory, 'SyncHistory')
    syncHistoryId = hid

    console.log(`âœ… [UniversalSync] SyncHistory criado: ${hid}`)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 3: PROCESSAR DADOS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    await syncReportsService.addReportLog(rid, 'info', 'Processando dados da fonte...')

    const sourceArray = Array.isArray(config.sourceData) ? config.sourceData : [config.sourceData]
    stats.total = sourceArray.length

    for (let i = 0; i < sourceArray.length; i += config.batchSize) {
      const batch = sourceArray.slice(i, i + config.batchSize)
      const batchNumber = Math.floor(i / config.batchSize) + 1
      const totalBatches = Math.ceil(sourceArray.length / config.batchSize)

      console.log(`ğŸ“¦ [UniversalSync] Processando batch ${batchNumber}/${totalBatches} (${batch.length} itens)`)

      await syncReportsService.addReportLog(
        rid,
        'info',
        `Processando batch ${batchNumber}/${totalBatches}`,
        { batchSize: batch.length, startIndex: i }
      )

      for (let j = 0; j < batch.length; j++) {
        const item = batch[j]

        try {
          const result = await processSyncItem(item, config)

          if (result.action === 'inserted') stats.inserted++
          else if (result.action === 'updated') stats.updated++
          else if (result.action === 'unchanged') stats.unchanged++
          else if (result.action === 'skipped') stats.skipped++

          if (config.onProgress) {
            const current = i + j + 1
            config.onProgress({
              current,
              total: stats.total,
              percentage: (current / stats.total) * 100,
              message: `Processando ${current}/${stats.total}`
            })
          }
        } catch (err: unknown) {
          stats.errors++

          const e = err as { message?: unknown; stack?: unknown; code?: unknown }
          const message = typeof e.message === 'string' ? e.message : 'Erro desconhecido'

          const syncError: SyncError = {
            message,
            userId:
              (typeof item.id === 'string' ? item.id : undefined) ||
              (typeof item.userId === 'string' ? item.userId : undefined),
            userEmail: item.email,
            stack: typeof e.stack === 'string' ? e.stack : undefined,
            code: typeof e.code === 'string' ? e.code : undefined
          }

          errors.push(syncError)

          await syncReportsService.addReportError(
            rid,
            syncError.message,
            syncError.userId,
            syncError.userEmail,
            syncError.stack
          )

          if (config.onError) config.onError(syncError)

          console.error('âŒ [UniversalSync] Erro ao processar item:', syncError.message)
        }
      }

      if (i + config.batchSize < sourceArray.length) {
        await new Promise<void>(resolve => {
          setTimeout(() => resolve(), 100)
        })
      }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 4: ATUALIZAR STATS
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    await syncReportsService.updateReportStats(rid, stats)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 5: FINALIZAR REPORT
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const finalStatus =
      stats.errors > 0 ? (stats.errors === stats.total ? 'failed' : 'partial') : 'success'

    await syncReportsService.completeReport(rid, finalStatus)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 6: FINALIZAR SYNCHISTORY
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const completedAt = new Date()
    const durationSeconds = Math.floor((completedAt.getTime() - new Date(syncHistory.startedAt).getTime()) / 1000)

    await SyncHistory.findByIdAndUpdate(syncHistoryId, {
      status: 'completed',
      completedAt,
      'stats.total': stats.total,
      'stats.added': stats.inserted,
      'stats.updated': stats.updated,
      'stats.errors': stats.errors,
      duration: durationSeconds,
      'metrics.duration': durationSeconds,
      'metrics.usersPerSecond': durationSeconds > 0 ? stats.total / durationSeconds : 0,
      'metrics.avgTimePerUser': stats.total > 0 ? (durationSeconds * 1000) / stats.total : 0
    })

    console.log(`âœ… [UniversalSync] SyncHistory finalizado: ${syncHistoryId}`)

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // STEP 7: CALCULAR DURAÃ‡ÃƒO E RETORNAR
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const duration = Math.floor((Date.now() - startTime) / 1000)

    console.log('âœ… [UniversalSync] Sync concluÃ­da!')
    console.log(`   â±ï¸ DuraÃ§Ã£o: ${duration}s`)
    console.log(`   ğŸ“Š Stats: ${stats.inserted} novos, ${stats.updated} atualizados, ${stats.errors} erros`)

    return {
      success: finalStatus !== 'failed',
      reportId: rid,
      syncHistoryId: hid,
      stats,
      duration,
      errors,
      warnings
    }
  } catch (err: unknown) {
    const e = err as { message?: unknown; stack?: unknown }
    const message = typeof e.message === 'string' ? e.message : 'Erro desconhecido'
    const stack = typeof e.stack === 'string' ? e.stack : undefined

    console.error('âŒ [UniversalSync] Erro fatal:', message)

    if (reportId) {
      await syncReportsService.addReportError(
        reportId,
        `Erro fatal: ${message}`,
        undefined,
        undefined,
        stack
      )
      await syncReportsService.completeReport(reportId, 'failed')
    }

    if (syncHistoryId) {
      const errorTime = new Date()
      const durationSeconds = Math.floor((errorTime.getTime() - new Date().getTime()) / 1000)
      
      await SyncHistory.findByIdAndUpdate(syncHistoryId, {
        status: 'failed',
        completedAt: errorTime,
        duration: durationSeconds,
        $push: { errorDetails: message },
        'stats.total': stats.total,
        'stats.added': stats.inserted,
        'stats.updated': stats.updated,
        'stats.errors': stats.errors + 1
      })
    }

    throw err
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPER: PROCESS SINGLE ITEM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const processSyncItem = async (
  item: UniversalSourceItem,
  config: UniversalSyncConfig
): Promise<ProcessItemResult> => {
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // VALIDAÃ‡ÃƒO INICIAL
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (!item.email || !item.email.trim()) {
    throw new Error('Item sem email')
  }

  const email = normalizeEmail(item.email)
  const name = item.name && item.name.trim() ? item.name.trim() : email

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // BUSCAR OU CRIAR USER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  let user = await User.findOne({ email })
  const isNew = !user

  if (!user) {
    user = await User.create({
      email,
      name,
      isActive: true
    })
    console.log(`âœ¨ [UniversalSync] Novo user criado: ${user.email}`)
  }

  const userIdStr = String(user._id)

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // PREPARAR UPDATES DO USER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  const updateFields: Record<string, unknown> = {}
  let needsUpdate = false

  if (name && user.name !== name) {
    updateFields.name = name
    needsUpdate = true
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // HOTMART - Schema Segregado
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (config.syncType === 'hotmart') {
    if (item.hotmartUserId) {
      updateFields['hotmart.hotmartUserId'] = item.hotmartUserId
      needsUpdate = true
    }

    const purchaseDate = toDateOrNull(item.purchaseDate)
    const signupDate = toDateOrNull(item.signupDate)
    const firstAccessDate = toDateOrNull(item.firstAccessDate)
    const lastAccessDate = toDateOrNull(item.lastAccessDate)

    if (purchaseDate) {
      updateFields['hotmart.purchaseDate'] = purchaseDate
      needsUpdate = true
    }
    if (signupDate) {
      updateFields['hotmart.signupDate'] = signupDate
      needsUpdate = true
    }
    if (firstAccessDate) {
      updateFields['hotmart.firstAccessDate'] = firstAccessDate
      needsUpdate = true
    }
    if (lastAccessDate) {
      updateFields['hotmart.lastAccessDate'] = lastAccessDate
      needsUpdate = true
    }

    if (item.plusAccess) {
      updateFields['hotmart.plusAccess'] = item.plusAccess
      needsUpdate = true
    }

    if (item.currentModule !== undefined) {
      updateFields['hotmart.currentModule'] = toNumber(item.currentModule, 0)
      needsUpdate = true
    }

    if (item.progress !== undefined) {
      updateFields['hotmart.progress'] = {
        totalProgress: toNumber(item.progress.percentage, 0),
        currentModule: toNumber(item.currentModule, 0),
        lastUpdatedAt: new Date()
      }
      needsUpdate = true
    }

    if (item.classId) {
      updateFields['hotmart.enrolledClasses'] = [
        {
          classId: item.classId,
          className: item.className || `Turma ${item.classId}`,
          source: 'hotmart',
          isActive: true,
          enrolledAt: purchaseDate || new Date()
        }
      ]
      needsUpdate = true
    }

    if (config.includeProgress && item.progress) {
      updateFields['hotmart.progress'] = {
        totalTimeMinutes: 0,
        completedLessons: toNumber(item.progress.completed, 0),
        lessonsData: (item.progress.lessons || []).map(l => ({
          lessonId: l.pageId,
          title: l.pageName,
          completed: Boolean(l.isCompleted),
          completedAt: toDateOrNull(l.completedDate),
          timeSpent: 0
        })),
        lastAccessDate: lastAccessDate || new Date()
      }
      needsUpdate = true
    }

    if (item.accessCount !== undefined || item.engagementLevel) {
      updateFields['hotmart.engagement'] = {
        accessCount: toNumber(item.accessCount, 0),
        engagementLevel: item.engagementLevel || 'NONE',
        engagementScore: 0,
        calculatedAt: new Date()
      }
      needsUpdate = true
    }

    updateFields['hotmart.lastSyncAt'] = new Date()
    updateFields['hotmart.syncVersion'] = '3.0'
    updateFields['metadata.updatedAt'] = new Date()
    updateFields['metadata.sources.hotmart.lastSync'] = new Date()
    updateFields['metadata.sources.hotmart.version'] = '3.0'
    needsUpdate = true
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // CURSEDUCA - Schema Segregado
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (config.syncType === 'curseduca') {
    if (item.curseducaUserId && item.curseducaUserId !== (user as any).curseduca?.curseducaUserId) {
      updateFields['curseduca.curseducaUserId'] = item.curseducaUserId
      needsUpdate = true
    }

    if (item.curseducaUuid) {
      updateFields['curseduca.curseducaUuid'] = item.curseducaUuid
      needsUpdate = true
    }

    if (item.groupId) {
      updateFields['curseduca.groups'] = [
        {
          groupId: item.groupId,
          groupName: item.groupName,
          joinedAt: new Date()
        }
      ]
      needsUpdate = true
    }

    updateFields['curseduca.lastSyncAt'] = new Date()
    updateFields['metadata.updatedAt'] = new Date()
    updateFields['metadata.sources.curseduca.lastSync'] = new Date()
    needsUpdate = true
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // DISCORD - Schema Segregado
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (config.syncType === 'discord') {
    if (item.discordUserId) {
      updateFields['discord.discordIds'] = [item.discordUserId]
      needsUpdate = true
    }

    if (item.username) {
      updateFields['discord.username'] = item.username
      needsUpdate = true
    }

    if (item.roles) {
      updateFields['discord.roles'] = item.roles
      needsUpdate = true
    }

    updateFields['discord.lastSyncAt'] = new Date()
    updateFields['metadata.updatedAt'] = new Date()
    updateFields['metadata.sources.discord.lastSync'] = new Date()
    needsUpdate = true
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // APLICAR UPDATES NO USER
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  if (needsUpdate) {
    await User.findByIdAndUpdate(userIdStr, { $set: updateFields })
    console.log(`ğŸ”„ [UniversalSync] User atualizado: ${user.email}`)
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // âœ… CRIAR/ATUALIZAR USERPRODUCT AUTOMATICAMENTE
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  try {
    // 1. Determinar productId usando funÃ§Ã£o escalÃ¡vel
    const productId = await determineProductId(item, config.syncType)
    
    if (!productId) {
      console.warn(`âš ï¸ [UniversalSync] Produto nÃ£o encontrado para ${config.syncType} - user: ${user.email}`)
      return { 
        action: isNew ? 'inserted' : (needsUpdate ? 'updated' : 'unchanged'), 
        userId: userIdStr 
      }
    }
    
    // 2. Verificar se UserProduct jÃ¡ existe
    const existingUP = await UserProduct.findOne({
      userId: userIdStr,
      productId: productId
    })
    
    if (existingUP) {
      // UserProduct jÃ¡ existe - atualizar apenas se necessÃ¡rio
      const upUpdateFields: Record<string, any> = {}
      let upNeedsUpdate = false
      
      // âœ… CORRIGIDO: Verificar se item.progress?.percentage existe
      if (item.progress?.percentage !== undefined) {
        const newPercentage = toNumber(item.progress.percentage, 0)
        if (existingUP.progress?.percentage !== newPercentage) {
          upUpdateFields['progress.percentage'] = newPercentage
          upUpdateFields['progress.lastActivity'] = new Date()
          upNeedsUpdate = true
        }
      }
      
      // âœ… CORRIGIDO: Verificar se item.engagement?.engagementScore existe
      if (item.engagement?.engagementScore !== undefined) {
        const newScore = toNumber(item.engagement.engagementScore, 0)
        if (existingUP.engagement?.engagementScore !== newScore) {
          upUpdateFields['engagement.engagementScore'] = newScore
          upUpdateFields['engagement.lastAction'] = new Date()
          upNeedsUpdate = true
        }
      }
      
      if (upNeedsUpdate) {
        await UserProduct.findByIdAndUpdate(existingUP._id, { $set: upUpdateFields })
        console.log(`   ğŸ“¦ UserProduct atualizado: ${user.email}`)
      }
      
    } else {
      // UserProduct NÃƒO existe - criar novo
      const enrolledAt = toDateOrNull(item.enrolledAt) || 
                        toDateOrNull(item.purchaseDate) ||
                        toDateOrNull(item.joinedDate) ||
                        new Date()
      
      const newUserProduct: any = {
        userId: userIdStr,
        productId: productId,
        platform: config.syncType,
        status: 'ACTIVE',
        source: 'PURCHASE',
        enrolledAt: enrolledAt,
        
        // Progresso - âœ… CORRIGIDO: usar optional chaining
        progress: {
          percentage: item.progress?.percentage ? toNumber(item.progress.percentage, 0) : 0,
          lastActivity: new Date()
        },
        
        // Engagement - âœ… CORRIGIDO: usar optional chaining
        engagement: {
          engagementScore: item.engagement?.engagementScore ? toNumber(item.engagement.engagementScore, 0) : 0,
          lastAction: new Date()
        }
      }
      
      // Dados especÃ­ficos da plataforma
      if (config.syncType === 'hotmart') {
        newUserProduct.hotmartData = {
          hotmartUserId: item.hotmartUserId,
          productCode: item.productCode
        }
      }
      
      if (config.syncType === 'curseduca') {
        newUserProduct.curseducaData = {
          curseducaUserId: item.curseducaUserId,
          groupId: item.groupId,
          subscriptionType: item.subscriptionType
        }
      }
      
      if (config.syncType === 'discord') {
        newUserProduct.discordData = {
          discordUserId: item.discordUserId,
          username: item.username
        }
      }
      
      await UserProduct.create(newUserProduct)
      console.log(`   âœ¨ UserProduct CRIADO: ${user.email} â†’ ${config.syncType}`)
    }
    
  } catch (upError: any) {
    console.error(`âŒ [UniversalSync] Erro ao criar/atualizar UserProduct para ${user.email}:`, upError.message)
    // NÃ£o falhar o sync todo - apenas logar erro
  }

  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  // RETORNAR RESULTADO - âœ… CORRIGIDO: sempre retorna
  // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
  
  return { 
    action: isNew ? 'inserted' : (needsUpdate ? 'updated' : 'unchanged'), 
    userId: userIdStr 
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EXPORT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

export default {
  executeUniversalSync
}